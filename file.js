/*
 * Coachium - file.js
 * - handles all workbook related stuff and file loading/saving
 * 
 * Made by Michal Procházka, 2021-2022.
 */

/*
 * tags_encode(s)
 * 
 * Generates tag escape characters for a given string.
 */

function tags_encode(s) {
	var el = document.createElement("div");
	el.innerText = el.textContent = s;
	return el.innerHTML;
}

/*
 * parse_object_to_xml()
 * 
 * Convert a JavaScript object (including all of its values) into XML.
 */

function parse_object_to_xml(object, prefix) {
	// Figure out what the object actually contains

	var xml = ""

	for(var key of Object.keys(object)) {
		// Figure out if the key contains an array, another object or a plain value

		if(typeof object[key] === 'object' && !Array.isArray(object[key])) {
			// The key is an object
		
			xml += prefix + "<" + key + ">\n"
			xml += parse_object_to_xml(object[key], prefix + " ")
			xml += prefix + "</" + key + ">\n"
		} else if(Array.isArray(object[key])) {
			// The key is an array

			xml += prefix + "<" + key + ">\n"

			for(var val of object[key]) {
				xml += prefix + " <val>" + tags_encode(val) + "</val>\n";
			}

			xml += prefix + "</" + key + ">\n"
		} else {
			// The key is a plain value

			xml += prefix + "<" + key + ">" + tags_encode(object[key]) + "</" + key + ">\n";
		}
	}

	return xml;
}

/*
 * xml_export(name)
 *
 * Generates a valid XML file of all current captures.
 */

function xml_export(name) {
	// File header

	xml = "<?xml version=\"1.0\"?>\n<coachium_file>\n\n<!--\n   " + name +
		"\n\n   This workbook file was generated by Coachium.\n\n   To view it properly, please visit:\n   https://coachium.prochazka.ml\n-->\n\n" + 
		" <version>1</version>\n";

	// Process all captures

	for(var capture of captures) {
		xml += " <capture>\n";
		xml += parse_object_to_xml(capture, "  ")
		xml += " </capture>\n";
	}

	// File terminator

	return xml + "</coachium_file>\n";
}

/*
 * conv_val(val)
 * 
 * If the input value is an empty string, it returns an empty string.
 * If the input value is a bool inside a string ("true" or "false"),
 *   it converts the string to a bool.
 * If the input value is a number inside a string, it converts
 *   the string to a number
 * Otherwise, it returns the untouched string.
 */

function conv_val(val) {
	if(val == "") return val;

	if(val == "true")  return true;
	if(val == "false") return false;

	if(!isNaN(val))
		return val * 1;

	return val;
}

/*
 * xml_import(input)
 * 
 * Imports an XML file. Simple as that.
 */

function xml_import(input) {
	captures = [];

	// TODO: input data validation!!!

	var xml = new DOMParser().parseFromString(input, "text/xml");

	// Parse each capture

	try {
		var loaded_captures = xml.getElementsByTagName("capture");

		for(var i = 0; i < loaded_captures.length; i++) {
			var capture = Object.assign({}, fresh_capture);

			// Figure out the type of each data object

			for(var key of Object.keys(capture)) {
				var param = loaded_captures[i].getElementsByTagName(key)[0];

				var param_vals = param.childNodes;

				if(param_vals.length > 1) {
					if(param_vals[1].nodeName == "val") {
						// The object is an array

						capture[key] = [];

						var p = 0;

						for(var param_val of param_vals) {
							if(param_val.nodeName == "#text") continue;

							capture[key][p++] = conv_val(param_val.textContent);
						}	
					} else {
						// The object is a JS object (port description)

						capture[key] = Object.assign({}, fresh_port_spec);

						for(var param_val of param_vals) {
							if(param_val.nodeName == "#text") continue;

							capture[key][param_val.nodeName] = conv_val(param_val.textContent);
						}	
					}
				} else {
					// The object is a plain value

					capture[key] = conv_val(param_vals[0].textContent);
				}
			}

			captures[i] = capture;
		}
	} catch(e) {
		get_win_el_tag(WINDOWID_FILE_IMPORT_ERR, "textarea") = e.stack;
		popup_window(WINDOWID_FILE_IMPORT_ERR);
	}
}

/*
 * load_file_local(are_you_sure)
 * 
 * Loads an XML file from local storage and processes it.
 * 
 * For extra safety, it throws a warning, since loading another file
 * will erase all current work.
 */

function load_file_local(are_you_sure) {
	if(get_id("openbutton").style.filter) return;

	if(captures.length > 0 && !are_you_sure) {
		// Let's not risk if we have some captures in memory

		popup_window(WINDOWID_IMPORT_OVERWRITE_WARN);
	} else {
		var element = document.createElement("input");

		element.type = "file";
		element.accept = ".coachium"

		element.onchange = () => {
			reader = new FileReader();

			reader.onload = (x) => {
				xml_import(x.target.result);
				selectedcapture = 0;
				main_window_reset();

				get_id("statusmsg").innerHTML = jslang.STATUS_FILE_LOADED;
			};

			reader.readAsText(element.files[0]);
		};

		element.click();
	}
}

/*
 * save_file_local(name_chosen)
 * 
 * Exports an XML file to local storage.
 */

function save_file_local(name_chosen) {
	if(get_id("savebutton").style.filter) return;

	var inputfield = get_win_el_tag(WINDOWID_LOCAL_SAVE_NAME, "input");

	if(name_chosen) {
		// Generate a fictional "a" element for saving the file

		var element = document.createElement("a");
		element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(xml_export(inputfield.value)));
		element.setAttribute("download", inputfield.value + ".coachium");
		element.click();

		get_id("statusmsg").innerHTML = jslang.STATUS_FILE_SAVED;
	} else {
		if(inputfield.value == "񂁩MISSING") {
			var d = new Date();
			var str = d.getDate() + ". " + (d.getMonth() + 1) + ". " + d.getFullYear();
			inputfield.value = format(jslang.DEFAULT_FILENAME, jslang.DEFAULT_USERNAME, str);
		}
		
		setTimeout(() => {
			inputfield.select();
		}, 100);

		popup_window(WINDOWID_LOCAL_SAVE_NAME);
	}
}

/*
 * create_capture()
 * 
 * Pops up the dialog for initializing a new capture.
 * 
 * Automatically selects the most ideal configuration based on connected sensors.
 */

function create_capture() {
	zoom_reset();
	
	if(ports[0].connected && ports[1].connected) {
		// We are going to capture from both sensors

		get_id("capturesetupsensors").selectedIndex = 0;
	} else if(ports[1].connected) {
		// From only the first sensor

		get_id("capturesetupsensors").selectedIndex = 2;
	} else {
		// From only the second sensor

		get_id("capturesetupsensors").selectedIndex = 1;
	}

	setTimeout(() => {
		get_id("capturesetupname").select();
	}, 100);

	popup_window(WINDOWID_CAPTURE_SETUP);
	capture_setup_check();
}

/*
 * remove_capture(are_you_sure)
 * 
 * Deletes the currently selected capture from the workbook.
 */

function remove_capture(are_you_sure) {
	if(get_id("removecapturebutton").style.filter) return;

	if(!are_you_sure) {
		// Better ask the user if they are sure to delete the current capture

		popup_window(WINDOWID_REMOVE_CAPTURE_WARN);
	} else {
		// Well, it's on you.

		var oldselected = selectedcapture;

		captures.splice(selectedcapture, 1);

		if(captures.length > 0) {
			if(selectedcapture >= captures.length)
				selectedcapture = captures.length - 1;
		} else {
			selectedcapture = 0;
		}

		get_id("statusmsg").innerHTML = format(jslang.STATUS_CAPTURE_REMOVED, oldselected + 1);

		main_window_reset();
	}
}

/*
 * remove_all_captures(are_you_sure)
 * 
 * Removes all captures from the current workbook.
 */

function remove_all_captures(are_you_sure) {
	if(get_id("removeeverythingbutton").style.filter) return;

	if(!are_you_sure) {
		// Better ask the user if they are sure to nuke literally everything

		popup_window(WINDOWID_NUKE_EVERYTHING_WARN);
	} else {
		// Well, it's on you.

		captures = [];
		selectedcapture = 0;

		get_id("statusmsg").innerHTML = jslang.STATUS_ALL_REMOVED;

		main_window_reset();
	}
}
